# 1 选择排序

```java
 public void select() {
        int arr[] = {8, 7, 6, 5, 4, 3, 2, 1};
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            int minIndedx = i;
            int min = arr[i];
            for (int j = i + 1; j < n; j++) {
                if (arr[i] > arr[j]) {
                    minIndedx = j;
                    min = arr[j];
                }
            }
            if (minIndedx != i) {
                arr[minIndedx] = arr[i];
                arr[i] = min;
            }
        }
        System.out.println(Arrays.toString(arr));
    }
```

思路



给定一个数组,我们选取第一个元素作为min,并且记录这个元素的下标

然后arr[0]与arr[1]---arr[n-1]中寻找最小值,然后将arr[minIndex]与arr[i]进行换位

---

举例 数组 [8,7,6,5,4,3,2]

第一次:  

> 选取元素8作为最小值,与[7,6,5,4,3,2]进行比较,寻找最小值,如果找到与8换位,并且记录两个的索引	
>
>  [2,7,6,5,4,3,8]

第二次:  

> 经过第一次排序,我们找到了2是这个数组中的最小值,所以这次我们在arr[1]---arr[n-1]中找到最小值,所以我们选组arr[1]=7,作为最小值,让arr[1]=7与arr[2]--arr[n-1] 也就是子数组[6,5,4,3,8]进行依次比较寻找最小值,如果找到将最小值与arr[1]=7换位,并且更新minIndex
>
> [2,3,7,6,5,4,8]

依次循环



# 2 插入排序

插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的



思想

> 插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。



在一个数组中,维持一个局部有序数组

举例 数组 [8,7,6,5,4,3,2]

首先 取出8和7 进行比较,拿到这两个值的索引,进行比较,8>7,将7赋值到value进行保存,然后将8赋值到7的位置,再把8的位置赋值为value

[8,8,6,5,4,3,2]  然后在把7赋值到元素第一个位置 [7,8,6,5,4,3,2]

取到8和6 发现8>6  把value赋值为6 然后推移有序子数组 7,8

[7,8,8,5,4,3,2] 此时7也大于6则继续推移 [7,7,8,5,4,3,2]  在将6赋值到第一个元素

依次往复

我们使用for循环,在无序数组中依次得到要进行排序的元素,我们将这个值赋值为value,同时我们也可以拿到索引`i`

因为我们是通过int i= 1开始循环,所以和1的前一位 0 进行比较

确定好和value比较的元素索引 index,我们进入while判断,并且通过在while中控制index--完成有序数组向后推移

我们通过while完成不断推移

在while内部,我们维护了 一个不断赋值的过程,这个就是保证了我们在无序数组中选择出来的元素在依次和有序数组中的元素进行比较,如果发现选择出来的value元素大于有序数组中的元素,就不进入判断,完成赋值



```java
public void test() {
        int arr[] = {8, 7, 6, 5, 4, 3, 2, 1};
        int index = 0;
        int value = 0;
        for (int i = 1; i < arr.length; i++) {
            //value的索引永远都比index大1
            value = arr[i];
            index = i - 1;
            // while相当于不断推移一个有序子数组,会在有序数组中依次两两比较,不断推移
            while (index >= 0 && value < arr[index]) {
              //对有序子数组进行移位
                arr[index + 1] = arr[index];
                index--;
            }
            //通过value记录最小值,然后当有序数组向后推移,再把value赋值到index+1的位置
            //因为index--
          //有序子数组移位完成,将value添加到有序位置
            arr[index+1]=value;
        }
        System.out.println(Arrays.toString(arr));
    }
```

# 3 希尔排序

希尔排序中心思想就是

通过局部大小比对,让一个乱序数组更倾向成为一个局部有序的数组,此时在针对整理过的数组进行插入排序,效率更高

通过不断给数组分组,使数组中元素在分组内有序,分组是按照步长来划分

步长: 数组长度/2 

举例`  int arr[] = {8, 1, 3, 4, 2,5};`

数组长度是6,那么 6/2=3   3/2=1  所以要进行两次次分组  通过两次分组 组内排序是数组处于局部有序

第一次:

分为3组分别是

8,4

1,2

3,5

8的索引是0,而4的索引是3 间隔3

1的索引是1,而2的索引是4 间隔3

...

分组内使用插入排序,是分组内有序,原数组变为: `{4,1,3,8,2,5}`

第二次

步长是1

分为1组

直接对`{4,1,3,8,2,5}`进行分组排序

此时步长是1

我们首先得到arr[1]=1,和arr[0]=8去比较,发现1<8 进行赋值,同时在while中对  j-=gap 保证 temp的正确位置

```java
public void test2() {
        int arr[] = {8, 1, 3, 4, 2,5};
        for (int gap = arr.length / 2; gap < arr.length; gap /= 2) {
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                int temp = arr[j];//给temp找到合适的位置
                //说明arr[j]对应的值,位置不对,进入判断,通过while找到合适的位置并插入
                if (arr[j] < arr[j - gap]) {
                    //{8, 1, 3, 4, 2, 7, 9, 4, 1, 3};
                    //temp依次与其同一有序数组中的元素进行比较,找到适合位置进行插入
                    while (j - gap >= 0 && temp < arr[j - gap]) {
                           arr[j]=arr[j-gap];
                           j-=gap;
                    }
                    //j-=gap  重新给arr[j]赋值
                    arr[j] = temp;
                }
            }
        }


    }
```

# 4 快速排序

快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列





# 5 归并排序

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。



